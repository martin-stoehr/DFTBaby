"""
compute atomic energies and orbitals self-consistently with DFT using LDA-functional + confining potential

0a. Start with guess intervals for eigenenergies
0b. Calculate orbitals with Numerov without XC potential => initial orbital guess

  --> 1.  Calculate electron density of atom with lowest orbitals occupied
          (or with orbitals from a predefined configuration occupied, i.e. (1s)^2(2s)^2(2p)^6...
          according to Aufbau principle.
 |    2.  Get LDA XC-potential from density and form KS hamiltonian including the confining potential.
  --- 3.  Compute KS orbitals and energies.
      4.  Repeat steps 1-3 until energies converge.
"""

import numpy
from numpy import array, zeros, ediff1d, linspace, sqrt, sum, pi, exp, log, inf, hstack, where
import itertools
from scipy import interpolate
from .RadialPotential import Coulomb, CoulombExpGrid
from . import XCFunctionals
from DFTB.AtomicData import nuclear_charge
from DFTB.Parameters import pseudo_orbital_x, pseudo_orbital_c

class AtomicKohnSham(Coulomb):
    has_confinement = False
    r0 = inf  # no confinement potential
    """
    (possibly confined) Kohn-Sham potential generated by N
    interacting electrons around a nucleus with positive charge Z.

    V(r) = -Z/r + V_Hartree(r) + V_xc(r) + V_conf(r)

    This class can find bound and continuum solutions to the
    Kohn-Sham equations with the help of methods
    pot.discrete_spectrum_angmom and pot.scattering_state
    which are documented in the base class RadialPotential

    """
    def __init__(self, Z, Nelec, eps=1e-7):
        """
        Parameters:
        ===========
        Z: atomic number
        Nelec: number of electrons
        eps: small distance to remove singularities at 1/r and l*(l+1)/(2*r^2)
             by replacing r with (r+eps)
        """
        self.Z = Z
        self.nuc_charge = nuclear_charge(self.Z)
        self.Nelec = Nelec
        # Unbound electrons see the Coulomb potential screened by the other electrons
        self.unscreened_charge = self.nuc_charge - self.Nelec
        self.eps = eps
    def setXCPotential(self, xcpot):
        """
        set exchange correlation potential

        Parameters:
        ===========
        xcpot: instance of an xc potential object
        """
        self.xcpot = xcpot
    def setDensity(self, n):
        """
        set radial, spherically averaged electron density
        values have to be defined on the same radial grid
        as given by pot.getRadialGrid()

        Parameters:
        ===========
        n:  density on the radial grid
        """
        self.n = n
    def getDensity(self):
        return self.n
    def setConfinementPotential(self, r0):
        """
        set quadratic the confinement potential (r/r0)^2

        Parameters:
        ===========
        r0: (r/r0)^2 confinement potential is added to the
           Kohn-Sham hamiltonian to cut away the diffuse tails
           of the orbitals
           (see section 3.1. in
            Koskinen, Maekinen "Density-functional tight-binding for beginners")
        """
        self.has_confinement = True
        self.r0 = r0
    def V(self, r):
        """
        effective radial potential, the angular potential 0.5*l*(l+1)/r^2 is added sperately
        """
        # Note: the grid r given to V(r) and the grid returned
        # by getRadialGrid are not the same for exponential grids
        self.Vh = hartree_potential(self.n, r, eps=self.eps, check_charge=self.Nelec)
#        self.Vxc = self.xcpot.vxc(self.n)
        npos = where(self.n <= 1.0e-20, 1.0e-20, self.n) # n == 0 causes zero division error
        self.xcpot.setGrid(r)
        self.Vxc = self.xcpot.vxc(npos)
#
        Vconf = pow(r/self.r0,2)
        Vr = -self.nuc_charge/(r + self.eps) + Vconf

        if self.Nelec > 1 or 1 == 1: # add unphysical self-interaction to be
                                     # consistent with other implementations
            # for atomic hydrogen there is no electron interaction
            Vr += self.Vh + self.Vxc

        return Vr
    def getTotalEnergies(self, orb_occ, orb_en):
        """
        compute total energies

        Parameters:
        ===========
        orb_occ: list of floats, fractional occupation of occupied orbitals
        orb_en: list of floats, energies of occupied orbitals

        Returns:
        ========
        Eenuc, Ecoul, Exc, Ebs, Ekin, Etot
        """
        r = self.getRadialGrid()
        dr = self.getVolumeElement()*ediff1d(r, to_end=r[-1]-r[-2])
        # check that density is normalized
        charge = sum(self.n*dr)
        print("integrated charge = %s" % charge)
        print("expected charge = %s" % self.Nelec)
        # coulombic electron-electron energy
        if self.Nelec > 1:
            self.Ecoul = 0.5*sum(self.Vh*self.n*dr)
            # exchange correlation energy
            self.Exc = sum(self.xcpot.exc(self.n)*self.n*dr)
            # exchange correlation potential
            Evxc = sum(self.Vxc*self.n*dr)
        else:
            self.Ecoul = 0.0
            self.Exc = 0.0
            Evxc = 0.0
        # electron-nuclear energy
        Venuc = -self.nuc_charge/(r+self.eps)
        self.Eenuc = sum(Venuc*self.n*dr)
        # band structure energy, sum of orbital energies
        self.Ebs = sum(fi*ei for (fi,ei) in zip(orb_occ, orb_en))
        # kinetic energy
        self.Ekin = self.Ebs - (self.Eenuc + 2.0*self.Ecoul + Evxc)
        # total energy
        self.Etot = self.Ekin + self.Eenuc + self.Ecoul + self.Exc
        print("Eenuc = %s" % self.Eenuc)
        print("Ecoul = %s" % self.Ecoul)
        print("Exc   = %s" % self.Exc)
        print("Ebs   = %s" % self.Ebs)
        print("Ekin  = %s" % self.Ekin)
        print("Etot  = %s" % self.Etot)
        return self.Eenuc, self.Ecoul, self.Exc, self.Ebs, self.Ekin, self.Etot

class AtomicKohnShamExpGrid(AtomicKohnSham, CoulombExpGrid):
    def V(self, rho):
        return super(AtomicKohnShamExpGrid, self).V(exp(rho))
#    def getRadialGrid(self):
#        return exp(super(AtomicKohnShamExpGrid, self).getRadialGrid())

def hartree_potential(n, r, eps=1.0e-8, check_charge=None):
    """
    integrate n(r')/|r'-r| on a spherical grid

    Parameters:
    ===========
    n: 1D numpy array, spherically averaged radial electron density
       at grid points of r.
    r: 1D numpy array, radial grid

    Returns:
    ========
    V_H: 1D numpy array, radial Hartree potential at the grid points of r.
    """
    dr = ediff1d(r, to_end=r[-1]-r[-2])
    charge = 4.0*pi*sum(pow(r,2)*n*dr)
    print("hartree potential")
    print("max(n) = %s" % n.max())
    print("integrated charge = %s" % charge)
    if check_charge:
        print("expected charge = %s" % check_charge)
        """check that the integrated charge does not differ to much from the expected charge"""
        assert abs((check_charge - charge))/(abs(check_charge)+1.0) < 0.01
    Riemann = zeros(r.shape)
    """add an infinitesimal, so that 1/(r+eps)^l never gives nan"""
    for i in range(0, len(r)):
        dR_asc = pow(r[i], 2)*n[i]*dr[i]
        dR_desc = r[-(i+1)]*n[-(i+1)]*dr[-(i+1)]
#        for j in range(i, len(r)):
#            Riemann[j] += dR_asc/(r[j]+eps)
#            Riemann[-(j+1)] += dR_desc
        #
        Riemann[i:len(r)] += dR_asc/(r[i:len(r)]+eps)
        Riemann[-len(r):-(i+1)] += dR_desc
        #
    V_H = 4.0*pi * Riemann
    return V_H

def radial_density(radial_wavefuncs, occupation, r, eps=1.0e-8):
    """
    compute radial density generated by a set of occupied orbitals.

    Parameters:
    ===========
    radial_wavefuncs: list of 1D numpy arrays,
       the list contains radial wave functions u_i(r) = r*R_i(r)
       at the grid points of r.
    occupations: list of integers, same length as radial_wavefuncs
       occupations[i] contains the number of electrons in orbitals
       with radial wavefunctions u_i(r)
    r: radial grid

    Returns:
    ========
    n: 1D numpy array, radial density at grid points of r.
    """
    n = zeros(r.shape)
    for o,nelec in enumerate(occupation):
        print("o= %s wavefunction.max() = %s" % (o, radial_wavefuncs[o].max()))
        n += nelec * pow(radial_wavefuncs[o], 2)
    n /= 4.0*pi*pow(r+eps,2)
    # At the origin the radial density should be exactly 0
    # However this causes a singularity in the xc-correlation
    # potential. Remove this singularity by adding an infinitesimal.
    if r[0] == 0.0:
        n[0] = 1.0e-30
    return n

def occupation_numbers(Nelec):
    """
    fill atomic orbitals in standard order with Nelec electrons
    and find the occupation of each level (n,l).
    Each l-shell may contain 2*(2*l+1) electrons.

    Parameters:
    ===========
    """
    Nfilled = 0
    for n in range(0, 10):
        for l in range(0,n+1):
            dne = min(2*(2*l+1), Nelec-Nfilled)
            if dne <= 0:
                raise StopIteration
            yield (dne,n,l)
            Nfilled += dne

def HOMO_qnumbers(Nelec):
    """
    find quantum numbers n and l of HOMO orbital
    """
    for (dne,n,l) in occupation_numbers(Nelec):
        pass
    return n,l

density_exponents = {(3, 3): 4.018750000000006, (1, 1): 1.892871093750002, (2, 2): 3.1069335937500049, \
                         (5,5): 3.0, (6,6): 2.5, (7,7): 3.15, (8,8): 3.3, (9,9): 4.0, (14,14): 2.5} # not realistic
"""
densitiy_exponents[(Z,Nelec)] contains the exponent
a such that the electron density of the atom Z with
Nelec electrons resembles
  n0 = Nelec * a^3/(8*pi) * exp(-a*r))

use the program fit_densities.py the generate this hash.
"""

class SCFNotConverged(Exception):
    pass

class SpectrumTooSmall(Exception):
    pass

class PseudoAtomDFT:
    converged = False
    have_n0 = False # do we have a starting density ?
    old_energies = None
    def __init__(self, Z, Nelec, numerov_conv=1.0e-8, en_conv=1.0e-5, \
                                 maxiter=100, damping=0.3, grid_spacing="linear", r0=inf):
        """
        Parameters:
        ===========
        Z: atomic number
        Nelec: number of electrons:
        numerov_conv: convergence threshold for matching condition
        en_conv: convergence threshold for LDA-DFT calculation
        maxiter: stop LDA-DFT calculation after maxiter iterations
        damping: 0.0 <= damping < 1.0, the updated electron density contains
           contains contribution from the density from the previous iteration
           to make convergence smoother,
           n_update = (1-damping)*n_new + damping*n_old
        grid_spacing: "linear" for equidistant radial grid r,
           "exponential" for rho=log(r) grid.
        r0: add confinement potential (r/r0)^2, default r0=inf means no confinement
        """
        self.Z = Z
        self.Nelec = Nelec
        self.grid_spacing = grid_spacing
        assert self.grid_spacing in ["linear", "exponential"]
        if self.grid_spacing == "linear":
            self.KS_pot = AtomicKohnSham(Z, Nelec, eps=numerov_conv)
        elif self.grid_spacing == "exponential":
            self.KS_pot = AtomicKohnShamExpGrid(Z, Nelec, eps=numerov_conv)
        self.r0 = r0
        self.xcpot = XCFunctionals.libXCFunctional(pseudo_orbital_x, pseudo_orbital_c)
#        self.xcpot = XCFunctionals.XC_PW92() #XCFunctionals.XC_VWN() #XCFunctionals.XC_PW92()
        self.KS_pot.setXCPotential( self.xcpot )

        self.en_conv = en_conv
        self.maxiter = maxiter
        assert 0.0 <= damping < 1.0
        self.damping = damping
        self.occupation = [occ for occ in occupation_numbers(self.Nelec)] # by default fill orbitals in standard order
        self.nmax = max([n for (nelec,n,l) in self.occupation])
        self.lmax = max([l for (nelec,n,l) in self.occupation])
        print("nmax = %s, lmax = %s" % (self.nmax, self.lmax))
        self.valence_qnumbers_nl = valence_qnumbers_nl(self.occupation)
    def setOccupation(self, occupation):
        """
        choose a non-standard occupation of the orbitals

        Parameters:
        ==========
        occupation: list of tuples of the form (Nelec,n,l)
          The orbital (n,l) is filled with Nelec electrons.
        """
        self.occupation = occupation
        # the orbital with the highest l does not have necessarily the highest energy
        self.nmax = max([n for (nelec,n,l) in self.occupation])
        self.lmax = max([l for (nelec,n,l) in self.occupation])
        print("nmax = %s, lmax = %s" % (self.nmax, self.lmax))
    def setValenceOrbitals(self, valence_qnumbers_nl, format=None):
        """
        specify which orbitals should be included in the minimal basis set.

        Parameters:
        ===========
        valence_qnumbers_nl:  list of tuples (n,l) or spectroscopic labels (e.g. "1s")
           with quantum numbers of valence orbitals
        format (optional): if None tuples (n,l) are expected
           if set to "spectroscopic" a list of orbital labels is expected
        """

        if format == "spectroscopic":
            self.valence_qnumbers_nl = []
            spectr2l = {"s": 0, "p": 1, "d": 2, "f": 3, "g": 4, "h": 5, "i": 6}
            for label in valence_qnumbers_nl:
                n = int(label[0])
                l = int(spectr2l[label[1]])
                self.valence_qnumbers_nl.append((n,l))
        else:
            self.valence_qnumbers_nl = valence_qnumbers_nl
        # increase lmax and nmax if unoccupied higher valence orbitals are requested
        for (n,l) in self.valence_qnumbers_nl:
            if n > self.nmax:
                self.nmax = n
            if l > self.lmax:
                self.lmax = l
        print("nmax = %s, lmax = %s" % (self.nmax, self.lmax))
    def getValenceOrbitals(self):
        return self.valence_qnumbers_nl
    def setRadialGrid(self, rmin, rmax, Npts):
        """
        determine the grid range, if grid_spacing=="exponential" the point
        density will be higher towards rmin and lower towards rmax.
        """
        if self.grid_spacing == "linear":
            r = linspace(rmin, rmax, Npts)
        elif self.grid_spacing == "exponential":
            r = linspace(log(max(rmin,1.0e-8)), log(rmax), Npts)
        self.KS_pot.setRadialGrid(r)
    def getRadialGrid(self):
#        return self.KS_pot.getRadialGrid()
        if self.grid_spacing == "linear":
            return self.KS_pot.getRadialGrid()
        elif self.grid_spacing == "exponential":
            return exp(self.KS_pot.getRadialGrid())
    def setEnergyRange(self, energy_range):
        """
        Set the energy range where we search for eigenvalues.
        It should start below the lowest orbital energy and extend
        beyond the LUMO. Each interval between to energy grid points
        is searched by bisection if a sign change occurs.

        Parameters:
        ===========
        energy_range: 1D numpy array
        """
        self.energy_range = energy_range
    def initialDensityGuess(self, guess=None):
        """
        Find initial guess for density. If a guess is provided as
        an argument, a spline is fitted to the initial density.

        Parameters:
        ===========
        guess: tuple of 1D numpy arrays, (r, radial_density)
           where r is the radial grid on which radial_density is defined
        """
        r = self.getRadialGrid()
        if guess != None:
            print("Start with density from previous calculation")
            rg, ng = guess
            tck = interpolate.splrep(rg, ng, s=0)
            n0 = abs(interpolate.splev(r,tck,der=0,ext=1))
            self.have_n0 = True
        elif (self.Z, self.Nelec) in density_exponents:
            print("Start with parametrized density n0(r) ~ exp(-a*r)")
            a = density_exponents[(self.Z, self.Nelec)]
            print("Got initial density with exponent a = %s" % a)
            n0 = self.Nelec * pow(a,3.0)/(8.0*pi) * exp(-a*r)
            # n0 satisfies  4pi integrate(0->infinity, r^2 n(r) dr) = Nelec
            self.have_n0 = True
        else:
            print("Start with 0 density")
            # initially use 0 density
            n0 = 0.0*r
        self.KS_pot.setDensity(n0)
    def solveKohnSham(self):
        """
        solve Kohn-Sham equations self-consistently
        """
        r = self.getRadialGrid()
        self.KS_pot.setConfinementPotential(self.r0)

        i = 0
        while True:
            print("ITERATION: %s" % i)
            print("**************")
            if not self.have_n0:
                if i == 0 :
                    # In the first iteration step the electron density is
                    # only a guess, so disable the xc-potential
                    self.KS_pot.setXCPotential( XCFunctionals.XC_None() )
                elif i == 1:
                    # After the first iteration we should have a reasonable
                    # electron density, enable LDA xc-potential
                    self.KS_pot.setXCPotential( self.xcpot )
            self.KS_pot.getRadialPotential()
            # find radial eigen energies and functions of Kohn-Sham hamiltonian
            self.spectrum, self.wavefuncs = \
                 self.KS_pot.discrete_spectrum(self.energy_range, self.lmax, self.nmax)
            # flattened list of energies of occupied orbitals
            # changes in orbital energy measure the convergence
            try:
                self.energies = array([self.spectrum[l][n-l] for (nelec,n,l) in self.occupation])
            except IndexError:
                raise SpectrumTooSmall("Numerov method did not find enough eigen states to accomodate all electrons."\
                                     + "\nTry changing the radial grid and the energy range or increase numerov_conv."\
                                     + "\nspectrum = %s" % self.spectrum)
            # average change in orbital energies between current and last step
            print("new energies = %s" % self.energies)
            print("old energies = %s" % self.old_energies)
            print("spectrum = %s" % self.spectrum)
            if i > 2:
                en_change = sum(abs(self.energies - self.old_energies))/float(len(self.energies))
                print("Energy Change (tolerance) = %s (%s)" % (en_change, self.en_conv))
                if en_change < self.en_conv:
                    print("orbital energies converged")
                    self.converged = True
                    self.getTotalEnergy()
                    print("total energy = %s" % self.Etot)
                    break
            self.old_energies = self.energies
            """
            # switch off damping
            if i > 10:
                print("Damping is switched off")
                damping = 0.0
            else:
                damping = self.damping
            """
            damping = self.damping
            if i > self.maxiter:
                raise SCFNotConverged("SCF calculation not converged after %s iterations." % self.maxiter)
            # find density for next iteration step
            occupied_orbs = [self.wavefuncs[l][n-l] for (nelec,n,l) in self.occupation]
            occ_numbers =[nelec for (nelec,n,l) in self.occupation]
            n_new = radial_density(occupied_orbs, occ_numbers, r, eps=self.KS_pot.eps)
            n_old = self.KS_pot.getDensity()
            self.n = (1.0-damping)*n_new + damping*n_old
            self.KS_pot.setDensity(self.n)
            i += 1
    def getTotalEnergy(self):
        """
        gives total DFT energy of pseudo atom
        """
        orb_occ = [nelec for (nelec,n,l) in self.occupation]
        orb_en = [self.energies[o] for o,(nelec,n,l) in enumerate(self.occupation)]
        self.KS_pot.getTotalEnergies(orb_occ, orb_en)
        self.Etot = self.KS_pot.Etot
        return self.Etot
    def charge_fluctuations(self, dq):
        """
        Determine how the total energy E(dq) changes if partial charge dq is added to the atom.
        The 1st and 2nd derivatives of E(dq) in dq=0 give the parameters -hardness and Hubbard U.

        Parameters:
        ===========
        dq: 1D numpy array of partial charges for which the total energies are calculated.
            The interval dq has to contain 0.0 and dq has to consist of at least 4 points.
            Partial charges are measured in multiples of electron charge, so positive charge
            fluctuations correspond to negatively charged atoms.

        Notes:
        ======
        DFT calculations can fail if the surplus charge is too large so that not enough bound
        orbitals are found to accomodate all partial charge.

        Returns:
        ========
        hardness chi, Hubbard U
        """
        assert dq.min() <= 0.0 <= dq.max()
        if 0.0 in dq:
            assert len(dq) > 3
        else:
            assert len(dq) >= 3
        q0 = self.KS_pot.Nelec
        n0 = self.KS_pot.getDensity()
        r = self.getRadialGrid()
        # split charge fluctuations into positive and negative intervals
        dqminus, dqplus = dq[dq<0.0], dq[dq>=0.0]
        Eqminus, Eqplus = zeros(dqminus.shape), zeros(dqplus.shape)
        qlast = q0
        n_last = n0
        for i in range(0, len(dqplus)):
            print("NEGATIVE CHARGE ON ATOM: %s e" % dqplus[i])
            q = q0+dqplus[i]
            self.converged = False
            self.KS_pot.Nelec = q
            # use the density of atom with charge dq[i] as starting guess
            # for DFT calculation for atom with charge dq[i+1]
            self.initialDensityGuess((r,q/qlast*n_last))
            self.setOccupation([occ for occ in occupation_numbers(q)])
            self.solveKohnSham()
            assert self.converged
            Eqplus[i] = self.Etot
            qlast = q
            n_last = self.KS_pot.getDensity()
        qlast = q0
        n_last = n0
        for i in reversed(list(range(0, len(dqminus)))):
            print("POSITIVE CHARGE ON ATOM: %s e" % dqminus[i])
            q = q0+dqminus[i]
            self.converged = False
            self.KS_pot.Nelec = q
            self.initialDensityGuess((r,q/qlast*n_last))
            self.setOccupation([occ for occ in occupation_numbers(q)])
            self.solveKohnSham()
            assert self.converged
            Eqminus[i] = self.Etot
            qlast = q
            n_last = self.KS_pot.getDensity()
        print("NEUTRAL ATOM:")
        # compute total energy of neutral atom, UGLY: neutral atom is calculated twice
        self.converged = False
        self.KS_pot.Nelec = q0
        self.initialDensityGuess((r,n0))
        self.setOccupation([occ for occ in occupation_numbers(q0)])
        self.solveKohnSham()
        assert self.converged
        E0 = self.Etot
        if 0.0 not in dq:
            dq = hstack((dqminus, array([0.0]), dqplus))
            Eq = hstack((Eqminus, array([E0]) , Eqplus))
        else:
            Eq = hstack((Eqminus, Eqplus))

        print("charge = %s" % dq)
        print("dE = %s" % (Eq-E0))
        # spline dE(q) as function of q and find 1st and 2nd derivatives in q=0
        tck = interpolate.splrep(dq, Eq-E0, s=0)
        dEdq = interpolate.splev(0,tck,der=1)
        d2Edq2 = interpolate.splev(0,tck,der=2)
        # E(dq) = E(dq=0) - chi*dq + 1/2*U*dq^2
        # see Koskinen/Maekinen (2009)
        self.hardness_chi = -dEdq
        self.Hubbard_U = d2Edq2
        print("hardness chi = %s" % self.hardness_chi)
        print("Hubbard U = %s" % self.Hubbard_U)
        self.partial_charge = dq
        self.charging_energy = Eq-E0
        return self.hardness_chi, self.Hubbard_U

    def charge_fluctuations2(self, dq_max, Nq, sides="+-"):
        """
        Determine how the total energy E(dq) changes if partial charge dq is added to the atom.
        The 1st and 2nd derivatives of E(dq) in dq=0 give the parameters -hardness and Hubbard U.

        Parameters:
        ===========
        dq_max: float maximum charge fluctuation
        Nq: energies are calculated at Nq points for partial charges in the interval +-[0,dq]
        sides:
               "+" only negative charge fluctuations q=q0+dq
               "-" only positive charge fluctuations q=q0-qd
               "+-" compute derivatives both from negative and positive charge fluctuations q=q0+-dq

        Notes:
        ======
        DFT calculations can fail if the surplus charge is too large so that not enough bound
        orbitals are found to accomodate all partial charge. Since DFT cannot describe atomic anions
        well, it is better to calculate chi and U from experimental ionization energies IE
        and electron affinities EA.

        Returns:
        ========
        hardness chi, Hubbard U
        """
        #assert self.converged
        q0 = self.KS_pot.Nelec
        r = self.getRadialGrid()
        n0 = self.KS_pot.getDensity()
        dq = linspace(0.0, dq_max, Nq)
        # vary the charge between Nelec-dq_max and Nelec+dq_max
        if "+" in sides:
            Eqplus = zeros(dq.shape)
            for i in range(1, Nq):
                print("NEGATIVE CHARGE ON ATOM: %s e" % dq[i])
                q = q0+dq[i]
                self.converged = False
                self.KS_pot.Nelec = q
                self.initialDensityGuess((r,q/q0*n0))
                self.setOccupation([occ for occ in occupation_numbers(q)])
                self.solveKohnSham()
                assert self.converged
                Eqplus[i] = self.Etot
        if "-" in sides:
            Eqminus= zeros(dq.shape)
            for i in range(1, Nq):
                print("POSITIVE CHARGE ON ATOM: -%s e" % dq[i])
                q = q0-dq[i]
                self.converged = False
                self.KS_pot.Nelec = q
                self.initialDensityGuess((r,q/q0*n0))
                self.setOccupation([occ for occ in occupation_numbers(q)])
                print("q0 = %s" % q0)
                self.solveKohnSham()
                assert self.converged
                Eqminus[i] = self.Etot
        print("NEUTRAL ATOM:")
        # compute total energy of neutral atom, UGLY: neutral atom is calculated twice
        self.converged = False
        self.KS_pot.Nelec = q0
        self.initialDensityGuess((r,n0))
        self.setOccupation([occ for occ in occupation_numbers(q0)])
        self.solveKohnSham()
        assert self.converged
        E0 = self.Etot

        if sides == "+":
            Eqplus[0] = E0
            Eq = Eqplus
            charge = dq
        elif sides == "-":
            Eqminus[0] = E0
            Eq = Eqminus
            charge = -dq[::-1]
        else:
            Eq = hstack((Eqminus[1:][::-1], Eqplus))
            charge = hstack((-dq[1:][::-1],dq))
        print("charge = %s" % charge)
        print("dE = %s" % (Eq-E0))
        # spline dE(q) as function of q and find 1st and 2nd derivatives in q=0
        tck = interpolate.splrep(charge, Eq-E0, s=0)
        dEdq = interpolate.splev(0,tck,der=1)
        d2Edq2 = interpolate.splev(0,tck,der=2)
        # E(dq) = E(dq=0) - chi*dq + 1/2*U*dq^2
        # see Koskinen/Maekinen (2009)
        self.hardness_chi = -dEdq
        self.Hubbard_U = d2Edq2
        print("hardness chi = %s" % self.hardness_chi)
        print("Hubbard U = %s" % self.Hubbard_U)
        self.partial_charge = charge
        self.charging_energy = Eq-E0
        return self.hardness_chi, self.Hubbard_U
    def getSolution(self):
        """
        gives the solution of the DFT calculation

        Returns: lists of energies and wave functions sorted by angular momenta
        ========
        spectrum: 2D list, spectrum[l][i] contains eigen energy
           of i-th wave function with angular momentum l
        wavefuncs: 2D list, wavefunc[l][i] contains i-th wave function
           with angular momentum l, u_l(r)

        spectrum[0][0] -> energy of 1s
        spectrum[0][1] -> energy of 2s
        spectrum[0][2] -> energy of 3s
        etc.
        spectrum[1][0] -> energy of 2p
        spectrum[1][1] -> energy of 3p
        spectrum[1][2] -> energy of 4p
        etc.
        spectrum[2][0] -> energy of 3d
        spectrum[2][1] -> energy of 4d
        etc.

        in general spectrum[l][n-l-1] contains the energy
        of shell n (starting from n=1) with angular
        momentum l (s=0, p=1, d=2, f=3,...)
        """
        if self.converged:
            return self.spectrum, self.wavefuncs
        else:
            raise Exception("You have to run an SCF calculation first.")
    def saveSolution(self, fh):
        """
        save radial wave functions, orbital energies and other quantities to a file.

        fh: open file handle
        """
        import pprint
        import sys
        if not self.converged:
            raise Exception("You have to run an SCF calculation first.")
        numpy.set_printoptions(threshold=sys.maxsize)
        pp = pprint.PrettyPrinter(depth=10)
        print("# This file has been generated automatically by %s." % sys.argv[0], file=fh)
        print("from numpy import array, inf", file=fh)
        print("Z = %s" % self.Z, file=fh)
        print("Nelec = %s" % self.Nelec, file=fh)
        print("# total DFT energies", file=fh)
        print("Eenuc = %s" % self.KS_pot.Eenuc, file=fh)
        print("Ecoul = %s" % self.KS_pot.Ecoul, file=fh)
        print("Exc   = %s" % self.KS_pot.Exc, file=fh)
        print("Ebs   = %s" % self.KS_pot.Ebs, file=fh)
        print("Ekin  = %s" % self.KS_pot.Ekin, file=fh)
        print("Etot  = %s" % self.KS_pot.Etot, file=fh)
        print("# confinement potential (r/r0)^2", file=fh)
        print("r0 = %s" % self.r0, file=fh)
        print("# exchange and correlation potential", file=fh)
        print("pseudo_orbital_x = \"%s\"" % pseudo_orbital_x, file=fh)
        print("pseudo_orbital_c = \"%s\"" % pseudo_orbital_c, file=fh)
        print("# radial grid", file=fh)
        print("r = \\\n%s" % pp.pformat(self.getRadialGrid()), file=fh)
        print("# radial electron density", file=fh)
        print("radial_density = \\\n%s" % pp.pformat(self.n), file=fh)
        print("# occupation numbers (<number of electrons in orbital n+1,l> , n, l)", file=fh)
        print("occupation = \\\n%s" % pp.pformat(self.occupation), file=fh)
        print("# self-consistent effective potential (including confinement but without angular l(l+1)/(2 r^2) part)", file=fh)
        print("effective_potential = \\\n%s" % pp.pformat(self.KS_pot.getRadialPotential()), file=fh)
        print("# orbital energies and wave functions of pseudoatom", file=fh)
        l2spectroscopic = ["s", "p", "d", "f", "g", "h", "i", "j"]
        en_vars = []
        u_vars = []
        nshell = []
        angmoms = []
        orb_names = []
        orb_occ = []
        for l,lshell_energies in enumerate(self.spectrum):
            for nml, en in enumerate(lshell_energies):
                n = nml+l+1
                nshell.append(n)
                orb_name = "%s%s" % (n, l2spectroscopic[l])
                # occupation of orbital n,l
                for occ in self.occupation:
                    if occ[1] == n-1 and occ[2] == l:
                        orb_occ.append(occ[0])
                        break
                else:
                    orb_occ.append(0)
                en_var = "energy_%s" % orb_name
                en_vars.append(en_var)
                print("%s = %s" % (en_var, en), file=fh)
                angmoms.append(l)
                u_var = "orbital_%s" % orb_name
                u_vars.append(u_var)
                orb_names.append(orb_name)
                print("%s = \\\n%s" % (u_var, pp.pformat(self.wavefuncs[l][nml])), file=fh)
        valence_orbitals = []
        for (n,l) in self.getValenceOrbitals():
            i = zip(nshell,angmoms).index((n,l))
            valence_orbitals.append(i)
        print("orbital_names = %s" % pp.pformat(orb_names), file=fh)
        print("# energy of each orbital", file=fh)
        print("energies = %s" % pp.pformat(en_vars).replace("'", ""), file=fh)
        print("radial_wavefunctions = %s" % pp.pformat(u_vars).replace("'", ""), file=fh)
        print("# principle n quantum number of each orbital", file=fh)
        print("nshell = %s" % pp.pformat(nshell), file=fh)
        print("# angular l quantum number of each orbital", file=fh)
        print("angular_momenta = %s" % pp.pformat(angmoms), file=fh)
        print("# occupation of each orbital", file=fh)
        print("orbital_occupation = %s" % pp.pformat(orb_occ), file=fh)
        print("# indeces of valence orbitals, which form the atomic centered basis", file=fh)
        print("valence_orbitals = %s" % pp.pformat(valence_orbitals), file=fh)
        if hasattr(self, "partial_charge"):
            print("# energy cost for adding or removing partial charges: E(dq) = E(dq=0) - chi*dq + 1/2*U*dq^2", file=fh)
            print("hardness_chi = %s" % self.hardness_chi, file=fh)
            print("Hubbard_U = %s" % self.Hubbard_U, file=fh)
            print("# dE(dq) for plotting ", file=fh)
            print("partial_charge = %s" % pp.pformat(self.partial_charge), file=fh)
            print("charging_energy = %s" % pp.pformat(self.charging_energy), file=fh)
            q_vars = ["hardness_chi", "Hubbard_U"]
        else:
            q_vars = []
        print("__all__ = %s" \
            % pp.pformat(["Z", "Nelec", "r0", "r", "radial_density", "occupation", "effective_potential", "orbital_names", "energies", "radial_wavefunctions", "angular_momenta", "valence_orbitals"] + en_vars + u_vars + q_vars), file=fh)


def valence_qnumbers_nl(occupation):
    """

    Parameters:
    ===========
    occupation: list of occupation numbers for each atomic valence orbital
     list of tuples (<number of electrons in orbital n+1,l> , n, l)

    Returns:
    ========
    list of tuples (n,l) with quantum numbers of valence orbitals
    """
    closed_shells = [2, 10, 18, 36, 54, 86]
    ecore = 0
    val_orbs = []
    for i,(nelec,nm1,l) in enumerate(occupation):
        if ecore in closed_shells:
            val_orbs = []
        ecore += nelec
        n = nm1 + 1
        val_orbs.append((n,l))
    return val_orbs

if __name__ == "__main__":
    atomdft = PseudoAtomDFT(1,1, grid_spacing="exponential")
    atomdft.setRadialGrid(0.0, 30.0, 1000)
    atomdft.initialDensityGuess()
    atomdft.setEnergyRange(linspace(-2.0, -0.0001, 100))
#    atomdft.setEnergyRange(linspace(-3.0, -0.001, 100)) # works for he
    atomdft.solveKohnSham()
    print(atomdft.getSolution()[0])
